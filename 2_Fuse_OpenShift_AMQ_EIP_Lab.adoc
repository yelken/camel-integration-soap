:scrollbar:
:data-uri:
:toc2:
:linkattrs:

== Enrich Content and Aggregate Data - Lab

In this lab, you develop routes that process the account records in JSON format, and through enrichment and aggregation create a more complete account record. The resulting record is stored in a database.

.Goals
* Design Apache Camel routes that consume JSON records from Red Hat AMQ
* Use the multicast EIP pattern to distribute the messages to the services
* Design the CXF web service using JAX-WS annotations to consume from SOAP backend service
* Consume from the backend REST service
* Aggregate the messages received using the aggregation EIP pattern
* Save the aggregated message in an SQL database using the Spring SQL component
+
image::images/Fuse_Exp_Usecase_Mod2.png[]

:numbered:


== Import the Project into Red Hat Developer Studio

. In Red Hat CodeReady Studio, import import these three projects located in the `$AI_EXERCISE_HOME/code/fuse/` directory into a new workspace:

* soap-cxfws-service
* rest-cxfrs-service
* amq-enrich-persist-lab

== Develop the Solution

=== REST Enrich Microservice

A REST microservice is used as a backend service for this solution. The REST service is provided in the project *rest-cxfrs-service*.

==== Inspect the REST Service

The REST service enriches the Account record.

. It consists of the `CustomerRest` REST service with the following annotations:
+
----
@Path("/customerservice/")
public interface CustomerRest {

@POST @Path("/enrich") @Consumes("application/json")
Account enrich(Account customer);
----

* The implementation class contains logic to enrich the `Account` POJO as follows:
** Based on the `geo` field of the `company` object, a Java enumerator maps region codes to regions
** `{"NE,MW,SO,WE"}` corresponds to `{"NORTH_EAST,MIDWEST,SOUTH,WEST"}`
** The enriched `Account` object is returned by the `enrich()` method

* To expose the REST service within Spring, you use the CXF component's `rsServer` server. This is defined in the Application.java.

* Check the application.properties and notice the *cxf-path* and *server.port*.

==== Run the REST service

. To run the REST service locally, run the following Apache Maven command from the project's root folder `$AI_EXERCISE_HOME/code/fuse/rest-cxfrs-service`:
+
----
$ mvn spring-boot:run -Dfabric8.skip
----

. The REST service should be running on port 8080, and can be accessed through URL: link:http://localhost:8080/rest/customerservice/enrich[http://localhost:8080/rest/customerservice/enrich]

. Try a sample request to the REST endpoint:
+
----
curl -k http://localhost:8080/rest/customerservice/enrich -X POST  -d '{"company":{"name":"Rotobots","geo":"NA","active":true},"contact":{"firstName":"Bill","lastName":"Smith","streetAddr":"100 N Park Ave.","city":"Phoenix","state":"AZ","zip":"85017","phone":"602-555-1100"}}' -H 'content-type: application/json'
----

. The response should be as follows:
+
----
{"clientId":0,"salesRepresentative":null,"company":{"name":"Rotobots","geo":"NORTH_AMERICA","active":true},"contact":{"firstName":"Bill","lastName":"Smith","streetAddr":"100 N Park Ave.","city":"Phoenix","state":"AZ","zip":"85017","phone":"602-555-1100"}}
----
+
NOTE: Notice that the content is enriched, and the GEO is replaced by the correct location.

==== Deploy to OpenShift Container Platform

. Create a project in OpenShift Container Platform for the REST service:
+
----
$ oc new-project rest-service
----

. To deploy the application to OpenShift Container Platform, execute the following maven command from the terminal:
+
----
$ mvn fabric8:deploy
----

. Check that the project is deployed successfully. A pod for the deployment *rest-cxfrs-service* should be started. Notice the URL of the endpoint for external traffic.

. You can test the REST service by running the same curl request above, replacing the localhost URL with the remote URL. The response received should be the same as for localhost.

=== SOAP Web Service

A SOAP Web Service is provided as part of the assets for this lab. This service is developed using CXF-RS, and deployed on Apache Karaf. The service is running on Red Hat Fuse 6.3. This service is available in the project *soap-cxfws-service*.

==== Inspect the Solution

. A service is defined in the `CustomerWS` interface using the `@Webservice` annotation that exposes an operation to update the received `Account` object:
+
----
@WebService
public interface CustomerWS {

    CorporateAccount updateAccount(Account account);
----

. Based on the `Account` POJO received, it creates a `CorporateAccount` POJO containing the same fields as `Account`, plus these additional fields:

* `id`: (int) Set as a random value using 1 to 100 as the range
* `salesContact`: (String) Randomly populated using a list of contacts

. Uses the `updateAccount` method implemented within the `CustomerWSImpl` class to return `CorporateAccount`.

. Uses an Apache Camel CXF endpoint bean to configure the service and create it using these parameters:

* `id`: `customerWebService`
* `address`: `http://localhost:8080/ws/customerService`
* `serviceClass`: `org.fuse.usecase.service.CustomerWS`
* `loggingFeatureEnabled`: `true`

==== Run the SOAP service

. To run the SOAP service locally, run the following Maven command from the project root folder `$AI_EXERCISE_HOME/code/fuse/soap-cxfws-service`:
+
----
$ mvn camel:run -Dfabric8.skip
----

. The Camel CXF service is running on port 8080, and can be accessed through URL: link:http://localhost:8080/ws/customerService[http://localhost:8080/ws/customerService]

. You can try a sample request using the SOAP UI:
+
----
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ser="http://service.usecase.fuse.org/">
   <soapenv:Header/>
   <soapenv:Body>
      <ser:updateAccount>
         <!--Optional:-->
         <arg0>
            <clientId>0</clientId>
            <!--Optional:-->
            <company>
               <active>true</active>
               <!--Optional:-->
               <geo>NA</geo>
               <!--Optional:-->
               <name>Bill Smith</name>
            </company>
            <!--Optional:-->
            <contact>
               <!--Optional:-->
               <city>Baltimore</city>
               <!--Optional:-->
               <firstName>Satya</firstName>
               <!--Optional:-->
               <lastName>Jayanti</lastName>
               <!--Optional:-->
               <phone>143-222-2344</phone>
               <!--Optional:-->
               <state>MD</state>
               <!--Optional:-->
               <streetAddr>1077 America Ave.</streetAddr>
               <!--Optional:-->
               <zip>11751</zip>
            </contact>
            <!--Optional:-->
            <salesRepresentative>?</salesRepresentative>
         </arg0>
      </ser:updateAccount>
   </soapenv:Body>
</soapenv:Envelope>
----

. The response should be as follows:
+
----
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
   <soap:Body>
      <ns2:updateAccountResponse xmlns:ns2="http://service.usecase.fuse.org/">
         <return>
            <company>
               <active>true</active>
               <geo>NA</geo>
               <name>Bill Smith</name>
            </company>
            <contact>
               <city>Baltimore</city>
               <firstName>Satya</firstName>
               <lastName>Jayanti</lastName>
               <phone>143-222-2344</phone>
               <state>MD</state>
               <streetAddr>1077 America Ave.</streetAddr>
               <zip>11751</zip>
            </contact>
            <id>44</id>
            <salesContact>Nandan Joshi</salesContact>
         </return>
      </ns2:updateAccountResponse>
   </soap:Body>
</soap:Envelope>
----
+
NOTE: Notice that the account is updated with the sales contact details.

==== Deploy to OpenShift Container Platform

. Create a project in OpenShift Container Platform for the SOAP service:
+
----
$ oc new-project soap-service
----

. By examining the code, note that the cxf endpoint is set to port 8080, as this is the default HTTP port exposed in the OpenShift Karaf container.
. Notice the OpenShift YAML files provided for deployment, service, and route configuration.
. To deploy the application to OpenShift Container Platform, execute the following Maven command from the terminal:
+
----
$ mvn fabric8:deploy
----

. Check that the project is deployed successfully. A pod for the deployment *soap-cxfws-service* should be started. Notice the URL of the endpoint for external traffic.

. You can test the SOAP service by running the same SOAP UI request above, replacing the localhost URL with the remote URL. The response received should be the same as for localhost.

=== Test the Integration Module

Now you will be testing the Camel routes that (1) enrich the Account data with the 2 backend services, (2) aggregate the responses, and finally (3) persist the data into a database table. You will be completing the code for this section in the project *amq-enrich-persist-lab*.

==== H2 database

The first Camel route updates the records in an embedded H2 database, running on localhost.

. Inspect the configuration details in the `pom.xml` and `application-dev.properties` files.
. Inspect a SQL script for creating the USECASE schema and the table required is provided in the `schema.sql` file.

You can access the H2 console by opening the URL: link:http://localhost:8080/h2-console[http://localhost:8080/h2-console]. Please enter the JDBC URL as *jdbc:h2:mem:testdb* and log in.

NOTE: The console will be available only after the routes are started. As the database is embedded, it does not persist data once the route is shut down.

==== Develop the Camel routes

. Analyze the second Camel route that consumes the JSON objects and starts from the *accountQueue*.
.. Note the AMQP configuration and queues based on the previous lab.
.. Note the how the message content is converted to a string, and how unmarshalling from JSON content to a POJO is done using the `<unmarshal>` processor.
* JSON library: `jackson`
* `unmarshalTypeName` attribute: `org.globex.Account`
* The result is used to multicast the exchange to the REST and web service endpoints.
+
IMPORTANT: It is a best practice not to multicast data in parallel. To simplify the legibility of the code, a direct endpoint (`callRestEndpoint`) is used to call the REST service and a different direct endpoint (`callWSEndpoint`) to call the web service service.

==== Define the REST Direct Routes

. To call the backend services, two Camel routes were created: one starting with `direct:callRestEndpoint` and the other with `direct:callWSEndpoint`.

* To correctly invoke the declared REST service, a HTTP producer component is used and make sure the following `{header,value}` pairs are specified:

** `Content-Type=application/json`
** `Accept=application/json`
** `CamelHttpMethod=POST`
** `CamelCxfRsUsingHttpAPI=True`


==== The Web Service Direct Route

. Note the direct web service route that starts with the `direct://callWSEndpoint` endpoint and calls the web service using the Camel CXF Producer.


==== The Aggregation Strategy

. From the results collected by the two services, analyse how the content is aggregated in the `multicast` processor to reconcile the information received from the `CorporateAccount` POJO with the `Account` POJO.

* This new `Account` POJO contains the aggregated result that is sent to another Apache Camel route to insert the row into the database.
+
NOTE: The aggregation strategy must be developed within the `AccountAggregator` class.

==== The Aggregated Data into the H2 Database

. Analyze the Apache Camel route that inserts the `Account` information into the `T_ACCOUNT` table of the `ACCOUNT` database.
..  The Spring SQL component in the route uses a SQL query to insert the `Account` record within the `option` parameter of the SQL endpoint.
* Method: `defineNamedParameters(Account account)`

.. The named parameters are defined using a `Map<String, Object>` created within a bean that is called by the route to set the body, before calling the SQL endpoint.
* Bean: `ProcessorBean.class`

. After calling the SQL endpoint, add a log message processor to display the contents of the received body.

==== Using a JUnit Test

. Analyze the JUnit test case that validates the `jackson` ObjectMapper can read the string content of the JSON `Account` message and generate an `Account` object.
* JUnit test class: `JacksonCompanyTest`

. Note the two assert conditions: one to check that the object is not null, and the other to verify that the name of the company is equal to "Robocops".


==== Build the `routing` Project and Test it Locally

. On the command line, run the following command in a terminal:
+
----
$ mvn spring-boot:run -Dfabric8.skip
----

* You will see output similar to the following:
+
----
{CONTACT_STATE=NC, SALES_CONTACT=Guillaume Nodet, CREATION_USER=fuse_usecase, CREATION_DATE=2015-12-11 18:18:01.55, CONTACT_PHONE=600-555-7000, CONTACT_CITY=Raleigh, CONTACT_ADDRESS=1101 Smith St., COMPANY_NAME=MountainBikers, COMPANY_ACTIVE=true, CLIENT_ID=46, CONTACT_LAST_NAME=Jungle, CONTACT_ZIP=27519, COMPANY_GEO=SOUTH_AMERICA, CONTACT_FIRST_NAME=George}
----
+
NOTE: Expect to see differences for `CREATION_DATE`, `SALES_CONTACT`, and `CLIENT_ID` because they are generated values.

. Check the database to ensure the records are populated correctly in the T_ACCOUNT table.

=== Deploy to OpenShift Container Platform

=== PostgreSQL Database

When we deploy the project to OpenShift Container Platform, we will use the PostgreSQL database and schema we set up earlier, instead of using the embedded H2 database. You can find the configuration details in the `application.properties` and `deployment.yml` files.

=== Deploying to OpenShift Container Platform

. Change the server.port to 8080.

. In a terminal window, navigate to the project's root folder and run:
+
----
$ mvn fabric8:deploy -Popenshift
----

. Check that the pod *amq-enrich-persist-lab* starts up correctly.
. Check that the route runs successfully, consuming all 3 messages from accountQueue, and writing to the database.


Congratulations, you have completed this lab.
